\documentclass[a4j]{jarticle}
    \usepackage[dvipdfmx]{graphicx}
    \usepackage[ top=25truemm,bottom=37truemm,left=25truemm,right=25truemm]
    {geometry}
    \usepackage{ascmac}
    \usepackage{array}
    \usepackage{here}
    \usepackage{url}
    \usepackage{listings, jlisting}
    \usepackage[subrefformat=parens]{subcaption}
    \renewcommand{\lstlistingname}{リスト}
\lstset{language=c,
  basicstyle=\ttfamily\scriptsize,
  commentstyle=\textit,
  classoffset=1,
  keywordstyle=\bfseries,
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\tiny,
  tabsize=4
}

\makeatletter
\def\@thesis{プログラミング演習 レポート}
\def\id#1{\def\@id{#1}}
\def\department#1{\def\@department{#1}}

\def\@maketitle{
\begin{center}
{\huge \@thesis \par} %修士論文と記載される部分
\vspace{10mm}
{\LARGE\bf \@title \par}% 論文のタイトル部分
\vspace{10mm}
{\Large \@date\par}	% 提出年月日部分
\vspace{20mm}
{\Large \@department \par}	% 所属部分
{\Large 学籍番号　\@id \par}	% 学籍番号部分
\vspace{10mm}
{\Large 氏名　\@author}% 氏名 
\end{center}
\par\vskip 1.5em
}

\title{アナログ時計}
\date{提出期限　2020年11月24日 17:00 \\ 提出日 2020年11月24日}
\department{組番号　408}
\id{17406}
\author{金澤雄大}

    \begin{document}
    \maketitle
    \thispagestyle{empty}
    \clearpage
    \addtocounter{page}{-1}
    \section{目的}
    後期のプログラミング演習で学習した内容の理解度を確認するために,アナログ時計のアプリケーションを作成することを
    目的とする.

    \section{実行環境}
    実行環境を表\ref{env}に示す.gccとは「GNU Compiler Collection」の略称で,GNUプロジェクトが公開しているコンパイラのことである.
    makeはMakefileにプログラムのコンパイルやリンクの方法を指示することで,コンパイルを簡単に行うことができるツールのことである.
    makeを用いることは,gccコンパイル時に,長いオプションを入力しなくてよい,ファイルの更新を取得して必要なものだけをコンパイルしてくれる
    という利点がある.

    \begin{table}[H]
      \caption{実行環境}
    \label{env}
    \begin{center}
        \begin{tabular}{c|l}\hline
          CPU & Intel(R) Core(TM) i7-6500U 2.50GHz  \\ 
          メモリ & 16.0GB DDR4 \\
          OS & Microsoft Windows 10 Home \\
          gcc &  version 9.3.0 \\
          make & version 4.3 \\ \hline
        \end{tabular}
    \end{center}
    \end{table}

    \section{アプリケーションの説明}
    \label{s3}
    図\ref{clock}に示すアナログ時計のアプリケーションを作成した.
    時計の表示にはライトモードとダークモードの2種類がある.ライトモードとは白を基調とした
    画面表示のことであり,ダークモードは黒を基調とした画面表示のことである.図\ref{light}はライトモードのときの時計の表示例,図\ref{dark}は
    ダークモードのときの時計の表示例である.モードの切り替えは,時計アプリのウィンドウをマウスで左クリックすることでできる.

        \begin{figure}[H]
          \begin{minipage}{0.5\hsize}
           \begin{center}
            \includegraphics[scale=1.2]{light.eps}
           \end{center}
           \subcaption{ライトモードの時計}
           \label{light}
          \end{minipage}
          \begin{minipage}{0.5\hsize}
           \begin{center}
            \includegraphics[scale=1.8]{dark.eps}
           \end{center}
           \subcaption{ダークモードの時計}
           \label{dark}
          \end{minipage}
          \caption{時計のアプリケーション}
          \label{clock}
         \end{figure}

         このアプリでは次に示すものを画面に描画する.アナログ時計の縁は内側と外側があり,回転している.
         回転方向は外側が時計回り,内側が反時計周りである.
         \begin{itemize}
          \item アナログ時計
          \item アナログ時計の縁
          \item 年,月,日,曜日,時,分,秒の文字列 
        \end{itemize}
         　また,レポートでは伝わらないが,ライトモードとダークモードでは画面に描画している
         アナログ時計および文字列の色が異なる.表\ref{color}に2つのモードにおける色の設定を示す.

         \begin{table}[H]
          \caption{色の設定}
        \label{color}
        \begin{center}
            \begin{tabular}{c|c|c}\hline
              描画内容 & ライトモードでの色 & ダークモードでの色 \\ \hline
              背景色 & 白 & 黒 \\
              年 月 日(曜日) &  オレンジ & ライトブルー \\
              時:分:秒 & 青 & 緑 \\
              時計の針(分針,時針)およびインデックス & 黒 & 白 \\
              時計の針(秒針) & 赤 & 赤 \\
              時計の縁(内側) & スプリンググリーン & 紫 \\
              時計の縁(外側) & ライムグリーン & ピンク \\ \hline
            \end{tabular}
        \end{center}
        \end{table}

    \section{プログラムの説明}
    \ref{s3}章で述べたアプリケーションを作成するためには次に示す機能を実装しなければならない.
    本章ではこれらを実装するプログラムの説明を行う.プログラムリスト全体は付録のリスト\ref{pro}を参照してほしい.
    \begin{itemize}
      \item ヘッダファイルの記述,オブジェクト形式マクロの宣言
      \item 初期化設定
      \item ウィンドウのリサイズへの対応
      \item タイマーを用いた時間の更新
      \item マウス入力の制御
      \item アナログ時計の針を表示する機能
      \item アナログ時計のインデックス,文字盤を表示する機能
      \item 年,月,日,曜日,時,分,秒の文字列を表示する機能
      \item 時計の縁が回転する機能 
    \end{itemize}

    \subsection{ヘッダファイルの記述,オブジェクト形式マクロの宣言}
    プログラムの実行に必要なヘッダファイルの記述,およびマクロを定義する.リスト\ref{include}に
    ヘッダファイルの記述,および必要なマクロを定義したコードを示す.「glut.h」がc言語でOpenGLを扱う
    ためのライブラリである.また,「time.h」は時間の取得を行うためのライブラリである.\\
    　本アプリではウィンドウサイズは320$\times$320に固定する.このため,リスト\ref{include}の8行目
    および9行目ではウィンドウのサイズを定義している.\\
    　リスト\ref{include}1行目から13行目ではグローバル変数の定義を行っている.変数dispModeは
    ライトモード,ダークモードの管理を行うための変数である.dispModeが1のときライトモード,0のとき
    ダークモードである.dispModeのデフォルト値はライトモードなっている.変数loop1,loop2はアナログ時計の縁を回転させるための変数である.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=include,caption=定数および変数の定義]
#include<GL/glut.h>
#include<stdio.h>
#include<time.h>
#include<math.h>
#include<string.h>

// windowのサイズを定義
#define WINDOW_W 320
#define WINDOW_H 320

int dispMode =0; // 0 : LIGHTMODE 1 : DARKMODE
double loop1=0; //use for design rotation
double loop2=0; //use for design rotation
                  \end{lstlisting}

  \subsection{初期化設定}
  メイン関数では全体の初期化および設定を行う.リスト\ref{main}にメイン関数のコードを示す.
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=main,caption=main関数]
int main(int argc,char **argv){
// 初期化処理
    // 引数処理
    glutInit(&argc,argv);
    // 初期Windowサイズ設定
    glutInitWindowSize(WINDOW_W,WINDOW_H);
    // 新規Window作成
    glutCreateWindow("clock");
    // 関数登録
    glutDisplayFunc(Display);
    glutReshapeFunc(Reshape);
    glutMouseFunc(Mouse);
    glutTimerFunc(500,Timer,0);
    // display初期化
    glutInitDisplayMode(GLUT_RGBA);
    glClearColor(0.96,0.96,1.0,1.0);
    // メインループ
    glutMainLoop();
    return 0;
}
  \end{lstlisting}   
  メイン関数の処理の説明を次に示す.
  \begin{enumerate}
    \item 引数の処理をglutInit関数で行う.本アプリでは引数は使用しないから,ここではglutInit関数に形式的に引数を渡している
    だけである(リスト\ref{main}の4行目).
    \item 最初に開くウィンドウのサイズを指定する.ウィンドウのサイズの初期設定はglutInitWindowSize関数で行う.glutInitWindowSize関数の
    引数は(幅,高さ)である.ここでは,オブジェクト形式マクロで定義したWINDOW\_Wを幅,WINDOW\_Hを高さとする(リスト\ref{main}の6行目).
    \item 開くウィンドウのサイズが決まったから,ウィンドウを生成する.ウィンドウの生成はglutCreateWindow関数で行う.glutCreateWindow関数の引数
    として渡している文字列は図\ref{clock}において,ウィンドウの左上に表示されている文字列である.リスト\ref{main}の8行目では「clock」という文字列
    をglutCreateWindow関数に渡しているから図\ref{clock}のウィンドウの左上には「clock」と表示されている.
    \item リスト\ref{main}の10行目から13行目はイベントによって呼び出される関数を定義している.本アプリにおいて,イベント(例としてユーザーからの入力やタイマーによる時間経過)
    はループを用いて逐一見張っている仕組みではない.本アプリのイベントに対する仕組みは,普段は何もせず,イベントが起こったときにそれに応じた処理を行うものである.
    このような仕組みをイベント駆動型プログラミングという.また,呼び出される関数をコールバック関数という.リスト\ref{main}では4つイベントに対してコールバック関数を設定している.
    それぞれのコールバックの呼び出されるイベントと処理内容の概要を次に示す.
    \begin{itemize}
      \item glutDisplayFunc $\dots$ ウィンドウの表示内容を更新するDisplay関数を呼び出す.
      \item glutReshapeFunc $\dots$ ウィンドウのサイズが変更されたときに,座標系およびウィンドウのサイズに関する設定するReshape関数を呼び出す.
      \item glutMouseFunc $\dots$ マウスの移動やクリックが発生したときに,マウスの移動やクリックに対する処理を行うMouse関数を呼び出す.
      \item glutTimerFunc $\dots$ 第一引数の時間(ミリ秒)が経過したときに,タイマーの処理を行うTimer関数を呼び出す.
    \end{itemize}
    \item リスト\ref{main}の15行目から16行目では生成したウィンドウに初期の背景を描画する処理を行っている.glutInitDisplayMode関数は色の指定を
    どのように行うかを設定している.ここでは色をRGBA,つまり赤(Red),緑(Green),青(Blue),透明度(Alpha)の4つの変数で指定する設定を行っている.そして
    glClearColor関数で初期の背景を描画する処理を行っている.注意として,glClearColor関数の引数は0から1までの値で色を指定する.ここでは,すべての値が
    ほぼ1であるため,白に近い色が描画される.
    \item 初期設定が終了したから,メインのループに入る関数であるglutMainLoop関数を実行する.
  \end{enumerate}

  \subsection{ウィンドウのリサイズへの対応}
  ウィンドウのリサイズへの対応について,仕様とプログラムでの実装部分を説明する.本アプリではウィンドウのリサイズを行っても,
  元のサイズ(320$\times$320)に戻される仕様になっている.これには2つの理由がある.1つ目は,アナログ時計を描画する部分において,
  ウィンドウのサイズに応じてアナログ時計の大きさを変化させるときに,中心からの距離の指定が複雑になることを防ぐためである.
  2つ目は,文字列を表示している関数は自由に文字の拡大縮小ができないため,画面の拡大縮小によって画面の大きさに対して不格好な描画になってしまうためである.\\
  　ウィンドウのサイズ変更イベントの処理を行う関数はReshape関数であった.リスト\ref{reshape}にReshape関数のコードを示す.
  リスト\ref{reshape}において,Reshape関数の引数は新しいウィンドウの幅w,高さhである.
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=reshape,caption=Reshape関数]
void Reshape(int w,int h){
    //printf("ウィンドウの幅と高さ=%d x %d\n",w,h);
    glViewport(0,0,w,h);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluOrtho2D(0,w,0,h);
    glScaled(1,-1,1);
    glTranslated(0,-h,0);

    //windowサイズ固定 
    glutReshapeWindow(WINDOW_W,WINDOW_H);
}    
      \end{lstlisting} 
      　Reshape関数の処理内容について説明する.ウィンドウの座標系はウィンドウを更新するたびに初期設定に戻ってしまう.ウィンドウの初期設定における
        座標系を図\ref{initzahyou}に示す.図\ref{initzahyou}の座標系では描画する図形の頂点の値を実数で与えないといけない
        ため,扱いにくい.そこで図\ref{generalzahyou}に示す座標系に設定しなおす.リスト\ref{reshape}の2行目から8行目では,
        図\ref{initzahyou}の座標系を,リスト\ref{generalzahyou}の座標系にする設定を行っている.\\
        　ウィンドウサイズの固定はリスト\ref{reshape}の11行目で行っている.glutReshapeWindow関数にウィンドウの
        幅,高さを引数として渡すことで内部でウィンドウのリサイズを行うことができる.

        \begin{figure}[H]
          \begin{minipage}{0.5\hsize}
           \begin{center}
            \includegraphics[scale=0.6]{czahyou.eps}
           \end{center}
           \subcaption{初期設定の座標系}
           \label{initzahyou}
          \end{minipage}
          \begin{minipage}{0.5\hsize}
           \begin{center}
            \includegraphics[scale=0.6]{zahyou.eps}
           \end{center}
           \subcaption{変換後の座標系}
           \label{generalzahyou}
          \end{minipage}
          \caption{座標系の設定}
          \label{zahyou}
         \end{figure}

    \subsection{タイマーを用いた画面描画の更新}
    タイマーによって一定時間おきに画面描画を更新する仕組みについて説明する.実装したいことは
    タイマーによって一定おきにイベントが発生させることと,画面描画を更新することに切り分けられる.
    本節では,前者のタイマーによって一定おきにイベントを発生させる仕組みについて説明する.後者は
    ここでは,画面描画を更新するDisplay関数がうまくやってくれると考える.\\
    　第一引数の時間(ミリ秒)が経過したときに,タイマーの処理を行う関数はTimer関数であった.Timer関数の
    コードをリスト\ref{timer}に示す.Timer関数はメイン関数(リスト\ref{main})の13行目に呼ばれる.
    ここでは500ミリ秒経過後にリスト\ref{timer}のTimer関数が呼ばれる設定になっている.\\
    　Timer関数の処理内容は,まず2行目でディスプレイの表示内容を更新するためのイベントを発生させるglutPostRedisplay
    関数が実行される.これによってdisplay関数が呼び出されて画面表示が更新される.次に,glutTimerFuncを
    再度実行する(リスト\ref{timer}の3行目).glutTimerFunc関数に登録されたタイマーは1度しか実行されないため,反復的に
    タイマーを利用するためにはイベントの設定を再度行う必要がある.
    
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=timer,caption=Timer関数]
void Timer(int value){
    glutPostRedisplay();
    glutTimerFunc(500,Timer,0);
}
            \end{lstlisting} 

    \subsection{マウス入力の制御}
    マウスの左クリックによってライトモードとダークモードが切り替わる仕組みについて説明する.
    マウスの移動やクリックが発生したときに,その動作に対する処理を行う関数はMouse関数であった.
    Mouse関数のコードをリスト\ref{mouse}に示す.Mouse関数の引数は,クリックされたボタンを示すb,
    ボタンの状態(押されたのか,離されたのか)を示すs,ボタンの座標(x,y)の4つである.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=mouse,caption=Mouse関数]
void Mouse(int b,int s,int x,int y){
    if(b==GLUT_LEFT_BUTTON){
        if(s==GLUT_UP){
            if(dispMode==1){
                dispMode=0;
            }else{
                dispMode=1;
            }
        }
        if(dispMode){
            glClearColor(0.15,0.15,0.15,1.0);
        }else{
            glClearColor(0.96,0.96,1.0,1.0);
        }
    }
}
            \end{lstlisting}
      　Mouse関数の処理内容について説明する.リスト\ref{mouse}の2行目から9行目では左クリックがされたときに
      dispModeを切り替える処理を行っている.リスト\ref{mouse}の2行目のif文で,イベントが起きたボタンが「左ボタン」であること
      を判定し,3行目のif文でボタンが「離された」ことを判定している.このように,マウスイベントの判定は,「左ボタンがクリックされたか」
      という事象を,イベントがあったボタンの種類,押されたのか離されたのか,という2つに分解して判定している.
      そして,5行目から8行目で2つのモードの切り替えを行っている.\\
      　リスト\ref{mouse}の10行目から14行目ではdispModeの変更に伴って,背景色を変更したいから,glClearColor関数を実行している.

    \subsection{アナログ時計の針を表示する機能}
    画面表示を行う関数としてDisplay関数を作成し,次の機能を実装する.Display関数の設計として,画面に表示する順番がある.
    アナログ時計の描画において,最も最前面に描画するべき情報は時計の針である.次に,時計のインデックス,文字盤,
    年月日に関する文字列の3つが同程度に重要である.時計の縁はデザイン性を高めるためのものであるから最も重要度が低い.
    したがって,フロー処理においてこれらを描画する順番は箇条書きの順番と一致する.Display関数における4つの機能の実装
    プログラムの説明は,プログラムの必要な部分を抜粋して行う.このため描画する順番がわかりずらい.プログラムソース全体
    は付録に載っているから,描画の順番は付録のリスト\ref{pro}を参照してほしい.
    \begin{enumerate}
      \item 時計の縁が回転する機能 
      \item 年,月,日,曜日,時,分,秒の文字列を表示する機能
      \item アナログ時計のインデックス,文字盤を表示する機能
      \item 時計の針を描画する機能 
    \end{enumerate}

    　アナログ時計の針を表示する機能について解説する.アナログ時計の「針を表示する機能」を実装するコードを抜粋したものを
    リスト\ref{display1}に示す.リスト\ref{display1}にはDisplay関数,calPosition関数,drawLine関数の3つの関数がある.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=display1,caption=針の描画の実装]
void Display(void){
    int i; //ループ用
    char *timestr; // 時間情報表示用文字列    
    // 画面サイズ取得
    int xc = glutGet(GLUT_WINDOW_WIDTH)/2;
    int yc = glutGet(GLUT_WINDOW_HEIGHT)/2+30; // y軸方向の中心は30ずらす.

    // 針の角度
    double thetas,thetam,thetah;
    // 針の座標
    int xs,ys,xm,ym,xh,yh;
    // 針の長さ
    int ls=80;
    int lm = 105;
    int lh = 90; 

    // 描画クリア
    glClear(GL_COLOR_BUFFER_BIT);
    
// 時間取得
    time_t tt;
    struct tm *ts;
    time(&tt);
    ts = localtime(&tt);

// 針の角度,座標を計算
    thetas = 2*M_PI*ts->tm_sec/60;
    thetam = 2*M_PI*(60*ts->tm_min+ts->tm_sec)/3600;
    thetah = 2*M_PI*(3600*(ts->tm_hour%12)+60*ts->tm_min+ts->tm_sec)/43200;
    calPosition(&xs,&ys,xc,yc,ls,thetas);
    calPosition(&xm,&ym,xc,yc,lm,thetam);
    calPosition(&xh,&yh,xc,yc,lh,thetah);

// 針を描画
    //時針描画
    if(dispMode){
    glColor3ub(255,255,255);
    }else{
    glColor3ub(0,0,0);
    }
    glLineWidth(5.0);
    drawLine(xc,yc,xh,yh);
    //分針描画
    glLineWidth(3.0);
    drawLine(xc,yc,xm,ym);
    //秒針描画
    glLineWidth(2.0);
    glColor3ub(255,0,0);
    drawLine(xc,yc,xs,ys);

    glFlush();
}

// 極座標と直交座標を変換
//極座標(r,theta)を(xc,yc)を原点とした直交座標(x,y)に変換
void calPosition(int *x,int *y,int xc,int yc,int r,double theta){
    *x = xc+r*sin(theta);
    *y = yc-r*cos(theta);
}

// lineを描画
//(x1,y1)と(x2,y2)を結ぶ直線を描画
void drawLine(int x1,int y1,int x2,int y2){
    glBegin(GL_LINES);
    glVertex2i(x1,y1);
    glVertex2i(x2,y2);
    glEnd();
};
            \end{lstlisting}
    
            Display関数の処理の内容を説明する.     
            リスト\ref{display1}の5行目および6行目では,ウィンドウの中央の座標を取得して変数xc,xyに代入している.
              glutGet関数はウィンドウや画面の情報を取得するための関数で,引数として「GLUT\_WINDOW\_WIDTH」を与えるとウィンドウの
              幅の情報が戻り値として得られる.同様に引数として「GLUT\_WINDOW\_HEIGHT」を与えることで,ウィンドウの高さの情報
              が取得できる.そして取得した値を2で割ることで,画面の中央の座標を得ることができる.6行目でycの値に30を足しているのは,
              画面中央を基準に時計を描画すると,文字列を表示する場所が狭くなってしまうためである.ycに30を足すことで,
              時計の中心をy軸方向30pixel下に移動している.\\
              　リスト\ref{display1}の9行目から15行目では秒針,分針,時針の3つの描画位置を計算するための変数を定義している.\\
              　リスト\ref{display1}の18行目では,画面表示をクリアな状態にするglClear関数を実行している.引数として
              与えている「GL\_COLOR\_BUFFER\_BIT」はカラーバッファとよばれる色情報を格納するメモリのことで,これを
              塗りつぶすことで,画面表示をクリアしている.\\
              　時計を作成するために,時間の取得を行う.時間の取得を行っている部分はリスト\ref{display1}の21行目から
              24行目である.「time.h」の関数を用いるため,リスト\ref{include}の3行目で「time.h」を
              読み込んでいる.時間の取得はtime\_t型の変数をtime関数にわたすことで取得することができる.\\
              　我々がほしい情報は現在時刻はtm構造体が保持しているため,time\_t型から変換を行う必要がある.この変換
              を行っているのが,リスト\ref{display1}の24行目である.tm構造体の構造はリスト\ref{tm}のようになっている.
              現在時間の情報の取得方法の例として,日付の情報がほしい場合は「ts-$>$tm\_mday」と記述することで取得できる.
              他の情報もリスト\ref{tm}を参考に取得できる.

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=tm,caption=tm構造体]
struct tm{
  int tm_sec; // 秒(0~60). 60は閏秒対応のため
  int tm_min; // 分(0~59).
  int tm_hour; // 時間(0~23).
  int tm_mday; // 日(1~31).
  int tm_mon; // 1月からの通算月数(0~11).
  int tm_year; // 1900年からの通算年数.
  int tm_wday; // 曜日(0~6).0が日曜日で6が土曜日.
  int tm_yday; // 1月1日からの通算日数(0~365).
  int tm_isdst; // 夏時間が有効かどうかのフラグ.
}
            \end{lstlisting}

            時間の取得ができたから,アナログ時計の針の角度および座標を計算する.リスト\ref{display1}では27行目から32行目である.
            27行目から29行目ではそれぞれの針の角度を計算している.角度は図\ref{tokei}に示すように時計の12時の位置を0度としている.
    \begin{figure}[H]
      \centering
      \includegraphics[scale=0.6]{tokei.eps}
      \caption{時計の針の角度}
       \label{tokei}
      \end{figure}

      時刻h時m分s秒のときの秒針の角度$\theta_s$は式(\ref{thetas})で与えられる.同様に分針の角度$\theta_m$は式(\ref{thetam}),
      時針の角度$\theta_h$は式(\ref{thetah})で計算できる.
          \begin{eqnarray}
            \label{thetas}
      \theta_s &=& \frac{2\pi s}{60}  \\
            \label{thetam}
      \theta_m &=& \frac{2\pi(60m+s)}{3600}  \\
            \label{thetah}
      \theta_h &=& \frac{2\pi(2600h+60m+s)}{43200}
        \end{eqnarray}

        角度が計算できたから,中心からの距離と角度の情報をもとに,針先の座標を計算する.針先の座標の計算はリスト\ref{display1}の
        30行目から32行目に示すようにcalPosition関数で行っている.calPosition関数の定義はリスト\ref{display1}の56行目から59行目
        にある.calPosition関数は,針先の座標を格納する変数x,yのポインタ,中心座標(xc,yc),中心からの距離r,角度thetaの6つを引数とし
        ている.計算結果は戻り値ではなくx,yに代入される.極座標($l$,$\theta$)から直交座標($x$,$y$)の変換は式(\ref{posix})および
        式(\ref{posiy})でできる.

        \begin{eqnarray}
          \label{posix}
    x &=& x_c + l \sin \theta  \\
          \label{posiy}
    y &=& y_c - l \cos \theta
      \end{eqnarray}
        
      針の座標が計算できたから,描画を行う.プログラムではリスト\ref{display1}の36行目から49行目である.36行目から40行目では,
      針の色の設定を行っている.まず,表示モードで色の場合分けがあるため,if文でdispModeでどちらのモードかを判定し,処理を分岐させる.\\
      　そして,glColor3ub関数で色の設定で行う.glColor3ub関数は引数として(R,G,B)の情報を0から255の整数で与えることで色の設定が行われる.
      設定は再度glColor3ub関数で違う色に設定するまで有効である.ダークモード(dispMode=1)のとき,針の色を(255,255,255),つまり白に設定している.
      ライトモード(dispMode=0)のときは,針の色を(0,0,0),つまり黒に設定している.このため,図\ref{clock}に示したように,時針と分針が
      ライトモードのときは黒,ダークモードのときは白で表示される.秒針が赤で描画されているのは,48行目でglColor3ub関数を呼び出して,
      色を(255,0,0),つまり赤に設定してから秒針を描画しているからである.\\
      　色の設定ができたから,線の太さの設定を行う.プログラムでは41,44,47行目である.41行目では,時針の太さをglLineWidth関数で設定している.
      glLineWidth関数は引数に太さを数値で与えると,値に応じた太さで線が描画させる.同様に,44行目で分針,47行目で秒針の太さを設定している.
      図\ref{clock}を見ると,それぞれの針で太さが変わっていることがわかる.\\
      　時針の描画は42行目,分針の描画は44行目,秒針の描画は49行目で行っている.針の描画を行う関数はdrawLine関数である.drawLine関数は
      リスト\ref{display1}の63行目から68行目で定義している.drawLine関数は引数として2点の座標(x1,y1),(x2,y2)を与えると,この2点を
      結ぶ線を描画する機能をもつ.線を結ぶ方法は64行目のglBegin関数で画面描画を行うことを宣言する.67行目のglEnd関数はglBegin関数と
      対になる関数である.直線を描くための点はglVertex2i関数で指定する.65および66行目のように,glVertex2i関数に座標をわたすことで
      直線を描くための点を指定できる.そして,glBegin関数に「GL\_LINES」を引数として指定することで直線を描くことができる.\\
      　ここまでで描画した内容はキューに貯められているだけで,まだ描画されていない.このキューの内容を実行して画面に反映させる関数が
      リスト\ref{display1}の51行目のglFlush関数である.

    \subsection{アナログ時計のインデックス,文字盤を表示する機能}
    アナログ時計のインデックス(目盛り)および文字盤を表示する機能の実装について説明する.リスト\ref{indexstr}に
    インデックスおよび文字盤を表示するコードを示す.\\
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=indexstr,caption=インデックスと文字盤の実装]
void Display(void){
  // インデックス描画用
  double l,theta; 
  int x1,x2,y1,y2;
  char s[3];

  // ---中略---

  // インデックス描画
  for(i=1;i<=60;i++){
      if(dispMode){
        glColor3ub(255,255,255);
      }else{
        glColor3ub(0,0,0);
      }
      glLineWidth(2.0);
      l=100; // インデックスの先端を長さ100にする
      if(i%5==0){  // 5の倍数の針は長くする
      l = 90; // インデックスの終端を長さ90にする
      }
      theta = 2*M_PI*i/60;
      calPosition(&x1,&y1,xc,yc,l,theta);
      l = 110;
      calPosition(&x2,&y2,xc,yc,l,theta);
      drawLine(x1,y1,x2,y2);

      if(i%5==0){ // 5の倍数のとき文字を表示
          sprintf(s,"%d",i/5);
          l =80; // 文字表示位置を80にする
          calPosition(&x2,&y2,xc,yc,l,theta);
          if(i/5<10){ // 一桁表示用
              glRasterPos2i(x2-5,y2+5);
              glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,s[0]);

          }else{ // 二桁表示用
              glRasterPos2i(x2-14,y2+5);
              glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,s[0]);
              glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,s[1]);
          }
      }
  }
}
    \end{lstlisting}
    　リスト\ref{indexstr}の2行目から5行目では,実装に必要な変数の定義を行っている.そして,リスト\ref{indexstr}の
    10行目から41行目のfor文がインデックスと文字盤を描画している部分である.for文の処理の大まかな
    内容は,インデックスの表示を,変数iが1から60までの60回ループすることで行っている.
    文字盤の表示は60回ループするなかで,iが5の倍数のときに行っている.\\
    リスト\ref{indexstr}の11行目から15行目では色の設定を行っている.そしてリスト\ref{indexstr}の
    16行目ではインデックスを描画する太さを2.0に設定している.\\
    　リスト\ref{indexstr}の17行目から25行目がインデックスの先端および終端の座標を計算して,描画する
    部分である.時計の針の描画は,画面の中心と先端を線で結ぶことで行っていた.インデックスの描画は,先端
    (中心に近いほう)の座標(x1,y1)と終端の座標(x2,y2)の二つを計算する必要がある.先端と終端の角度は同じであるから
    長さを変えて計算を行えばよい.リスト\ref{indexstr}の17行目から22行目では時計の先端の座標を計算している.
    長さはインデックスが5の倍数のとき,つまり文字盤を表示するとき90に設定し,それ以外の場合は100にしている.
    こうすることで,図\ref{clock}に示すように,文字盤が表示されているインデックスの長さを伸ばして,見やすくしている.
    長さの設定ができたから,リスト\ref{indexstr}の22行目に示すように,calPosition関数(リスト\ref{display1}の56行目から59行目)
    を用いて先端の座標を計算する.同様に,リスト\ref{indexstr}の23,24行目で,長さを110に設定して終端の座標を計算
    している.最後にdrawLine関数に先端と終端の座標を引数として与えることでインデックスが描画される.\\
    　リスト\ref{indexstr}の27行目から40行目ではループ変数iが5の倍数のときに文字盤を表示する機能を実装している.
    まず,27行目のif文で変数iが5の倍数かどうかを判定し,処理が分岐する.変数iが5の倍数のとき28行目のsprintf
    関数を用いて文字列sに「i/5」の文字列を代入する.例えば変数iの値が5のときsには「1」の文字列が入る.
    sprintfはprintfで標準出力される文字列が第一引数の変数に代入される.このため,「i/5」の値が文字列sに
    代入される.そして,29行目および30行目で文字列を描画する位置を計算する.\\
    　文字盤の表示は文字列が一桁(1～9)のときと二桁(10～12)のときで分けて処理を行っている.リスト\ref{indexstr}の
    31行目から33行目が文字列が一桁のときの処理である.まず,文字列を描画する座標をglRasterPos2i関数に与える.
    calPosition関数の計算結果からx座標を$-5$,y座標を$+5$しているのは表示位置を微調整しているためである.
    そして,glutBitmapCharacter関数で文字列の描画を行う.glutBitmapCharacter関数の第一引数は描画するフォント
    の種類を指定している.第二引数は表示する文字を与える.glutBitmapCharacter関数は一文字ずつしか描画できないが,
    表示文字が一文字のため,s[0]を与えている.\\
    　二桁(10～12)を表示する処理はリスト\ref{indexstr}の36行目から38行目である.まず,一桁目の描画と同様に
    glRasterPos2iで描画する座標を指定する.ここでも表示位置の微調整を行っている.そしてglutBitmapCharacter関数
    で1文字目を表示する.glutBitmapCharacter関数には自動で次の文字の描画位置に座標をずらす機能があるから,
    続けて2文字目を表示する.これで2桁のときも画面に描画できる.リスト\ref{indexstr}の5行目で文字列sを要素数
    3で定義しており,3文字目を描画しなくてよいのかと疑問に思うかもしれないが,3文字目はナル文字と呼ばれる文字列の終わり
    を示す文字が入っているため描画する必要はない.

    \subsection{年,月,日,曜日,時,分,秒の文字列を表示する機能}
    日付の情報を画面に描画する機能の実装について説明する.リスト\ref{date}に日付情報を描画する機能を実装するた
    めのコードを示す.

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=date,caption=日付情報を描画する機能の実装]
void Display(void){
  char *timestr; // 時間情報表示用文字列
  int month,wday; // 月の番号,曜日の番号取得用
  int timestr_len = 12; //year+space+space+month+space+(+)+\0
  // 月の名前を定義
  char month_eg[12][10] = {{"January"},{"February"},{"March"},{"April"},{"May"}
  ,{"June"},{"July"},{"August"},{"Septermber"},{"October"},{"November"},{"December"}};
  // 曜日の名前を定義
  char wday_eg[7][10] = {{"Sunday"},{"Monday"},{"Tuesday"},{"Wednesday"},{"Thursday"}
  ,{"Friday"},{"Saturday"}};

  -----中略-----

  // year,month,dayを表示
  month = ts->tm_mon; // 月の番号を取得
  wday =  ts->tm_wday; // 曜日の番号を取得 
  // 可変文字列生成
  timestr_len+=strlen(month_eg[month])+strlen(wday_eg[wday]); // 文字数計算
  timestr = (char *)malloc(timestr_len*sizeof(char)); // 配列確保
  // timestrに文字列書き込み
  sprintf(timestr,"%d %s %02d (%s)",1900+ts->tm_year,month_eg[month],ts->tm_mday
  ,wday_eg[wday]); 
  // 文字列表示
  if(dispMode){
  glColor3ub(0,191,255);
  }else{
  glColor3ub(255,102,0);
  }
  Printstr(xc-(18*timestr_len/4),30+1,timestr,timestr_len); // 文字列表示
  // 領域解放
  free(timestr);

//hour,min,secを表示
  // 文字列生成
  timestr = (char *)malloc(9*sizeof(char)); // 配列確保
  // timestrに文字列書き込み
  sprintf(timestr,"%02d:%02d:%02d",ts->tm_hour,ts->tm_min,ts->tm_sec); 
  timestr_len = strlen(timestr); // 文字列の長さを取得
  // 文字列表示
  if(dispMode){
  glColor3ub(0,255,0);
  }else{
  glColor3ub(0,0,205);
  }
  // 文字列表示(太文字用)
  Printstr(xc-(18*timestr_len/4)+1,60,timestr,timestr_len); 
  if(dispMode){
  glColor3ub(51,255,102);
  }else{
  glColor3ub(0,0,205);
  }
  Printstr(xc-(18*timestr_len/4),60,timestr,timestr_len); // 文字列表示
  // 領域解放
  free(timestr);
}

// 文字列描画
//座標(x,y)を初期位置として文字列str(文字列の長さstrlen)を画面に描画
void Printstr(int x,int y,char *str,int strlen){
    int i;
    glRasterPos2i(x,y);
    for(i=0;i<strlen;i++){
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,str[i]);
    }
}
            \end{lstlisting}

    　リスト\ref{date}の2行目から10行目では日付情報の描画に必要な変数を定義している.4行目の変数timestr\_lenは
    文字列を格納する配列を動的生成するために文字数を計算している.ここでは月名および曜日名のように文字列が
    可変である部分を除いた文字数を計算している.画面に描画したい文字は「\verb*|2020 [月名] 06 ([曜日])|」のような形
    である.([ ]で囲んでいる部分が可変).「\verb*| |」は空白(スペース)を表している.年は4桁を仮定し,日は2桁で表示する
    仕様にすると,固定で必要な文字は11文字である.変数timestr\_lenには11文字にナル文字用の1文字を足した12文字を代入している.\\
    　6行目のmonth\_eg配列は月の名前を保持するための配列である.また,9行目のwday\_eg配列は曜日の名前を保持するための配列である.\\
    　リスト\ref{date}の15行目から31行目では図\ref{clock}の「2020 November 17 (Tuesday)」にあたる部分を描画している.
    15行目では月の番号,16行目では曜日の番号を取得している.18行目から22行目では画面に表示する文字列の生成を行っている.
    18行目ではstrlen関数を用いて,表示すべき月および曜日の文字数を計算し,変数timestr\_lenに加算している.18行目で必要な文字列
    の長さがわかったから,領域の確保を行う.領域の確保は19行目でmalloc関数を用いて行っている.領域が確保できたから文字列timestr
    に文字列を代入する.文字列の代入は21行目でsprintf関数を用いて行っている.日の文字数を2桁にする処理もsprinf関数で行っている.\\
    　表示する文字列が準備できたから,描画を行う.描画はリスト\ref{date}の24行目から29行目で行っている.まず24行目から27行目で描画する
    色の設定を行う.ダークモードのときはライトブルー,ライトモードのときはオレンジになるように設定している.29行目で文字列の描画
    をPrintstr関数を用いて行っている.Printstr関数の定義はリスト\ref{date}の59行目から65行目にある.Printstr関数は引数として
    1文字目を描画する座標(x,y),および文字列,および文字列の長さを与える必要がある.Printstr関数の内部では,引数として受け取った
    文字列をglutBitmapCharacterで1文字ずつ表示する処理を行っている.これによって文字列が画面に表示される.最後にmallocで確保し
    た領域を解放する.領域の解放は31行目でfree関数を用いて行っている.\\
    　同じ方法で時,分,秒の文字列を描画する.リスト\ref{date}において時,分,秒の文字列を描画している部分は35行目から
    54行目である.まず,配列の確保を動的に行う.表示したい文字列は「\verb*|22:16:20|」のような形をしている.
    すべての桁を2文字で表示する仕様にすると,必要な文字数は8文字である.リスト\ref{date}の35行目では,8文字にナル文字の1
    文字を足した9文字の長さの配列を確保している.そのほかの処理は日付情報を画面に描画したときと同様である.46行目で
    文字列を再度描画しているのは,表示する位置を$y$方向に1pxずらして,表示を太文字にするためである.このため,図\ref{clock}
    で日付の表示と,太字で描画した時間の描画では,文字の太さに違いが見られる.
    　
    \subsection{時計の縁が回転する機能}
    時計の縁を描画し,回転させる機能の実装について説明する.リスト\ref{huti}に時計の縁を描画し,回転させる機能を実装
    するためのコードを示す.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=huti,caption=時計の縁の実装]
void Display(void){

  -----中略-----

  // デザイン描画
  l=128;
  if(dispMode){
  glColor3ub(218,112,214);
  }else{
  glColor3ub(127,255,0);
  }
  drawDesign(xc,yc,0,130,l,loop1);
  l=124;
  if(dispMode){
  glColor3ub(38,38,38);
  }else{
  glColor3ub(245,245,255);
  }
  drawDesign(xc,yc,-1,131,l,loop1);



  l=128;
  if(dispMode){
  glColor3ub(218,112,214);
  }else{
  glColor3ub(127,255,0);
  }
  drawDesign(xc,yc,160,270,l,loop1);
  l=124;
  if(dispMode){
  glColor3ub(38,38,38);
  }else{
  glColor3ub(245,245,255);
  }
  drawDesign(xc,yc,159,271,l,loop1);





  l=121;
  if(dispMode){
  glColor3ub(153,50,204);
  }else{
  glColor3ub(0,250,154);
  }
  drawDesign(xc,yc,70,200,l,loop2);
  l=118;
  if(dispMode){
  glColor3ub(38,38,38);
  }else{
  glColor3ub(245,245,255);
  }
  drawDesign(xc,yc,69,201,l,loop2);



  l=121;
  if(dispMode){
  glColor3ub(153,50,204);
  }else{
  glColor3ub(0,250,154);
  }
  drawDesign(xc,yc,240,380,l,loop2);
  l=118;
  if(dispMode){
  glColor3ub(38,38,38);
  }else{
  glColor3ub(245,245,255);
  }
  drawDesign(xc,yc,239,381,l,loop2);

// デザイン回転
  loop1+=0.05;
  loop2-=0.1;
  if(loop1>=2*M_PI){
      loop1=0;
  }
  if(loop2<=-2*M_PI){
      loop2=0;
  }
}

// デザインを描画
// (xc,yc)を原点とする極座標をとる.
// この極座標でthetaStartからtheraEndまで,長さlの扇形を描画する.
// loopは扇形を回転させる変数.
void drawDesign(int xc,int yc,int thetaStart,int thetaEnd,int l,double loop){
    int x,y,i;
    double theta;
    glBegin(GL_POLYGON);
    for(i=thetaStart;i<=thetaEnd;i++){
        theta= 2*M_PI*i/360;
        calPosition(&x,&y,xc,yc,l,theta+loop);
        glVertex2i(x,y);
    }
    glEnd();
}
            \end{lstlisting}
    
    　リスト\ref{huti}のDisplay関数において,時計の縁を描画する部分は次の4つに分けられる.
    ただし角度は回転を行う前,つまり初期の角度である.
    \begin{enumerate}
      \item 外側の縁を描画する部分(0度から130度) : リスト\ref{huti}の6～19行目
      \item 外側の縁を描画する部分(160度から270度) : リスト\ref{huti}の23～36行目
      \item 内側の縁を描画する部分(70度から200度) : リスト\ref{huti}の42～55行目
      \item 内側の縁を描画する部分(240度から380度) : リスト\ref{huti}の59～72行目
    \end{enumerate}
    　描画する位置や角度は値の変更によって容易に行えるから,ここでは「外側の縁を描画する
    部分(0度から130度)」について説明する.プログラムではリスト\ref{huti}の6～19行目である.
    時計の縁の描画は2つの扇を描画することで行っている.まず,0度から130度,長さが128の扇形
    を描画する.色はライトモードではライムグリーン,ダークモードではパープルである.次に-1度
    から131度,長さが124の扇形を描画する.色は背景色と同じ色を用いる.最初に描いた扇形に,
    背景色と同じで,長さが短い扇形を上書きすることで,図\ref{clock}で円の弧のような図形が
    描かれる.上書きする扇形の角度を,元の扇形の角度より大きくしているのは,角度が同じであると
    端の線が表示される場合があるためである.\\
    　プログラムでは,まず,6行目で長さを128に設定し,7行目から11行目で色の設定を行っている.そして,
    12行目でdrawDesign関数を用いて色付きの扇形を描画している.drawDesign関数の定義は
    リスト\ref{huti}の89行目から,99行目である.drawDesign関数は引数として,中心座標(xc,yc),
    扇形を描く角度thetaStart,thetaEnd,長さl,扇形を回転させる変数loopをとる.
    扇形を描く角度は,例として0度から90度の扇形を描く場合は,thetaStartに0,thetaEndに90を与える.
    drawDesignの内部では,GL\_POLYGONおよびfor文を用いて扇形の描画を行っている.GL\_POLYGONは
    指定された点を結ぶ図形を描く設定である.for文ではthetaStartからthetaEndまで1度ずつcalPosition関数
    で座標を計算して,glVertex2i関数で描画を行っている.calPosition関数の角度にtheta$+$loopを与えることで
    図形全体が回転する仕組みになっている.\\
    　背景色と同じ扇形の描画もdrawDesign関数を用いることで同様に行う.これによって,角度および長さを変更
    するだけで時計の縁を描画することができる.
    他の3つの時計の縁も,同様にして描画できる.\\
    　時計の縁全体を回転させる処理はリスト\ref{huti}の75行目から83行目で行っている.変数loop1,loop2はリスト
    \ref{include}でグローバル変数として定義されていた.Display関数が呼ばれるたびにloop1は$+0.05$,loop2は$-0.1$
    される.この変数をdrawDesign関数に与えることで図形全体が回転する.77行目から79行目では,loop1が$2\pi$より大きい,
    つまり図形が一周したときに変数loop1を0に戻す処理を行っている.これを行うことで変数loop1が無限に大きくなることを
    防いでいる.同様に,80行目から82行目では変数loop2が$-2\pi$より小さくなったときに,変数loop2を0に戻す処理を行っている.

    \section{ビルド方法の説明}
    ビルド方法について説明する.まず,ダウンロードした「j17406.tar.gz」を解凍する.解凍は次のコマンドで行う.
  \begin{screen}
    gzip -dv j17406.tar.gz \\
    tar xvf j17406.tar
  \end{screen}
  　解凍したファイルは次のような構造になっている.
  \begin{screen}
j17406 \\
├── Makefile \\
├── j17406.c \\
├── myicon.o \\
├── myicon.rc \\
├── readme.txt \\
└── smalltile.ico 
  \end{screen}
  　解凍ができたから次に示すコマンドでビルドを行う.makeを実行するとリスト\ref{war}のような警告がでるが時計のアプリは問題なく実行できる.
  \begin{screen}
make
  \end{screen}

  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=war,caption=コンパイル時の警告]
In file included from j17406.c:2:
/usr/include/opengl/GL/glut.h:562:21: 警告: ‘glutCreateMenu_ATEXIT_HACK’ defined but 
not used [-Wunused-function]
  562 | static int APIENTRY glutCreateMenu_ATEXIT_HACK(void (GLUTCALLBACK *func)(int)) 
  { return __glutCreateMenuWithExit(func, exit); }
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~
gcc j17406.o  -o j17406.exe -lglpng -lglut32 -lglu32 -lopengl32 -lm myicon.o
  \end{lstlisting}

    「make」のみでコンパイルが終わる仕組みを説明する.Makefileのコードをリスト\ref{make}に示す.
  ファイルの中にはmakeでビルドを行うためのMakefileが用意されている.
  リスト\ref{make}の6行目は最終的に出来上がるファイルを指定している.ここではj17406.exeという
  ファイルが出来上がる.9行目ではコンパイルするファイルを指定している.コンパイルするファイルはj17406.c
  であるからこれを指定する.18行目から22行目では,コンパイラ,リンカの指定,およびコンパイルオプションの指定
  を行っている.これらの設定をMakefileに書いておくことで,「make」と入力するだけでコンパイルが行われる.\\
  　36,37行目ではmakeコマンドにオプションをつけ「make clean」としたときの処理を記述している.
  「make clean」を実行すると,makeを実行したときに生成される「.o」といったファイルが削除される.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=make,caption=Makefile]
#
# Makefile
#

# 最終目的ファイル
TARGET = j17406.exe

# ソースファイル一覧(*.c)の一覧
SRCS = j17406.c

# オブジェクトファイル一覧(*.o)
OBJS = ${SRCS:.c=.o}

# ヘッダファイルの一覧(何もなし)
HEADERS = 

# コンパイラ・リンカの指定
CC = gcc
CCFLAGS = -Wall -I/usr/include/opengl
LD = gcc
LDFLAGS =
LIBS = -lglpng -lglut32 -lglu32 -lopengl32 -lm myicon.o

#OBJSからTARGETを作る方法
$(TARGET) : $(OBJS)
	$(LD) $(OBJS) $(LDFLAGS) -o $(TARGET) $(LIBS)

# *.cから*.oを作る方法
.c.o:
	$(CC) $(CCFLAGS) -c $<

# *.oはHEADERSとMakefileに依存
$(OBJS) : $(HEADERS) Makefile

# make cleanとしたときに実行されるコマンド
clean :
	rm -f $(TARGET) $(OBJS) core *~
            \end{lstlisting}

    \section{実行結果とその説明}
    本章では,次に示す実行結果およびその説明について述べる.
    \begin{enumerate}
      \item アプリ実行時の画面表示
      \item 時計の時間があっているかの確認
      \item ライトモードとダークモードの切り替え
    \end{enumerate}

    \subsection{アプリ実行時の画面表示}
    アプリを次のコマンドから,もしくはエクスプローラーでj17406.exeをダブルクリックして実行すると
    図\ref{start}の画面が立ち上がる.
    \begin{screen}
.\verb*|\|j17406.exe
        \end{screen}
            
  \begin{figure}[H]
      \centering
      \includegraphics[scale=1.2]{start.eps}
      \caption{アプリ実行時に立ち上がる画面}
       \label{start}
      \end{figure}

      　アプリを立ち上げたときのモードの設定はライトモードになっていた.図\ref{start}で,アプリを立ち上げた
      とき,画面はライトモードになっていることがわかる.また,時計の上に文字列として日付および時間の情報が表示されている.
      時計の縁は縁全体の回転が0度のとき,次のような設定になっていた.
      \begin{enumerate}
        \item 外側の縁(0度から130度)
        \item 外側の縁(160度から270度)
        \item 内側の縁(70度から200度) 
        \item 内側の縁(240度から380度)
      \end{enumerate}
      　12時を0度とすると,角度と時間の関係は表\ref{timedo}に示すようになっている.
      表\ref{timedo}で示している角度と時間の関係は,縁を描画する初期設定の角度になっている
      ものである.
      \begin{table}[H]
        \caption{角度と時間の関係}
      \label{timedo}
      \begin{center}
          \begin{tabular}{c|c}\hline
            角度(度) & 時間(分) \\ \hline 
            0 & 0.00 \\
            70 & 11.7 \\
            130 & 21.67 \\
            160 & 26.67 \\
            200 & 33.33 \\
            240 & 40.00 \\
            270 & 45.00 \\
            380 & 3.33 \\ \hline
          \end{tabular}
      \end{center}
      \end{table}

      　表\ref{timedo}から,1つ目の外側の縁は,0度から130度であるから,時計のインデックスで表すと
      0分から21.67分までの角度の弧を描くことがわかる.
      図\ref{start}において,1つ目の外側の縁は0分からおおよそ21.67分の弧を描いている.
      他の縁も同様にして,正しい角度で描けていることがわかる.このことから
      回転のない初期状態のとき,時計の縁が正しく描けていることがわかる.

      \subsection{時計の時間があっているかの確認}
      アプリの時計の時間があっているか確認する.図\ref{time1}および図\ref{time2}に,
      アプリの画面とWindowsの時計を同時に表示したときの画像を示す.どちらの図も
      左側にアプリの時計,右側にWindowsの時計が表示されている.\\
      \begin{figure}[H]
        \centering
        \includegraphics[scale=1.2]{timecheck.eps}
        \caption{アプリの時間の確認1}
         \label{time1}
        \end{figure}

        \begin{figure}[H]
          \centering
          \includegraphics[scale=1.2]{timecheck2.eps}
          \caption{アプリの時間の確認}
           \label{time2}
          \end{figure}
      　図\ref{time1}のWindowsの時計から,図\ref{time1}は「2020年11月21日19時56分09秒」に実行したものであることが
      わかる.さらに,Windowsのカレンダーから曜日が土曜日(Saturday)であることがわかる.そして,アプリの時計は
      「2020 November 21(Saturday) 19:56:09」になっており,Widnowsの時計と一致していることがわかる.\\
      　図\ref{time2}も同様に確認する.図\ref{time2}のWindowsの時計は「2020年11月22日08時48分36秒 日曜日」であることが
      わかる.アプリの時計もWindowsの時計と同じになっていることがわかる.これによって,Windowsの時計とアプリの時計が一致している
      ことが確認できた.

        \subsection{ライトモードとダークモードの切り替え}
        ライトモードとダークモードの切り替えを左クリックで行えることを確認する.
        図\ref{w1}から図\ref{w2}にライトモードとダークモードを切り替えたときの画面を示す.
        アプリを立ち上げると図\ref{w1}に示すようにライトモードになっている.
        この状態で左クリックを1回押すとダークモードに切り替わる.図\ref{b}は左クリックを1回
        押したときの結果である.図\ref{b}より,ライトモードで左クリックを1回押すとダークモードに切り替わることが
        確認できた.\\
        　ダークモードで左クリックを1回押すとライトモードに切り替わることを確認する.図\ref{w2}に
        図\ref{b}の状態で左クリックを1回押した結果を示す.図\ref{w2}より,ダークモードで左クリックを
        1回押すとライトモードに切り替わることが確認できた.

        \begin{figure}[H]
          \centering
          \includegraphics[scale=1.1]{white1.eps}
          \caption{左クリックを押す前の画面}
           \label{w1}
          \end{figure}

          \begin{figure}[H]
          \centering
          \includegraphics[scale=1.1]{black.eps}
          \caption{1回左クリックしたときの画面}
           \label{b}
          \end{figure}

          \begin{figure}[H]
            \centering
            \includegraphics[scale=1.1]{white2.eps}
            \caption{2回左クリックしたときの画面}
             \label{w2}
            \end{figure}

        \section{感想}
        今回のレポートではプログラムを書く部分よりも,時計やアイコンのデザインを決めて,描くほうが難しく時間がかかりました.
        時計のデザインはなるべくシンプルで自分が作業中のディスプレイの片隅に置いておきたいというコンセプトで作成しました.
        次のレポートでは,もう少し複雑な描画を用いてみたいと考えています.
        
        \section{付録}
        リスト\ref{pro}にプログラム全体のソースコードを示す.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=pro,caption=時計アプリのソースコード]
// 17406 金澤雄大 11/17
#include<GL/glut.h>
#include<stdio.h>
#include<time.h>
#include<math.h>
#include<string.h>

// windowのサイズを定義
#define WINDOW_W 320
#define WINDOW_H 320

int dispMode =0; // 0 : LIGHTMODE 1 : DARKMODE
double loop1=0; //use for design rotation
double loop2=0; //use for design rotation
void Display(void);
void Reshape(int,int);
void Timer(int);
void Printstr(int,int,char *,int);
void calPosition(int *,int *,int,int,int,double);
void drawLine(int,int,int,int);
void drawDesign(int,int,int,int,int,double);
void Mouse(int,int,int,int);

int main(int argc,char **argv){
// 初期化処理
    // 引数処理
    glutInit(&argc,argv);
    // 初期Windowサイズ設定
    glutInitWindowSize(WINDOW_W,WINDOW_H);
    // 新規Window作成
    glutCreateWindow("clock");
    // 関数登録
    glutDisplayFunc(Display);
    glutReshapeFunc(Reshape);
    glutMouseFunc(Mouse);
    glutTimerFunc(500,Timer,0);
    // display初期化
    glutInitDisplayMode(GLUT_RGBA);
    glClearColor(0.96,0.96,1.0,1.0);
    
    // メインループ
    glutMainLoop();
    return 0;
}

void Display(void){
    int i; //ループ用
    char *timestr; // 時間情報表示用文字列
    int month,wday; // 月の番号,曜日の番号取得用
    int timestr_len = 12; //year+space+space+month+space+(+)+\0
    // 月の名前を定義
    char month_eg[12][10] = {{"January"},{"February"},{"March"},{"April"},{"May"},
    {"June"},{"July"},{"August"},{"Septermber"},{"October"},{"November"},{"December"}};
    // 曜日の名前を定義
    char wday_eg[7][10] = {{"Sunday"},{"Monday"},{"Tuesday"},{"Wednesday"},{"Thursday"},
    {"Friday"},{"Saturday"}};
    
    // 画面サイズ取得
    int xc = glutGet(GLUT_WINDOW_WIDTH)/2;
    int yc = glutGet(GLUT_WINDOW_HEIGHT)/2+30; // y軸方向の中心は30ずらす.
    
    // インデックス描画用
    double l,theta; 
    int x1,x2,y1,y2;
    char s[3];

    // 針の角度
    double thetas,thetam,thetah;
    // 針の座標
    int xs,ys,xm,ym,xh,yh;
    // 針の長さ
    int ls=80;
    int lm = 105;
    int lh = 90; 

    // 描画クリア
    glClear(GL_COLOR_BUFFER_BIT);
    
// 時間取得
    time_t tt;
    struct tm *ts;
    time(&tt);
    ts = localtime(&tt);

// 針の角度,座標を計算
    thetas = 2*M_PI*ts->tm_sec/60;
    thetam = 2*M_PI*(60*ts->tm_min+ts->tm_sec)/3600;
    thetah = 2*M_PI*(3600*(ts->tm_hour%12)+60*ts->tm_min+ts->tm_sec)/43200;
    calPosition(&xs,&ys,xc,yc,ls,thetas);
    calPosition(&xm,&ym,xc,yc,lm,thetam);
    calPosition(&xh,&yh,xc,yc,lh,thetah);

// デザイン描画
    l=128;
    if(dispMode){
    glColor3ub(218,112,214);
    }else{
    glColor3ub(127,255,0);
    }
    drawDesign(xc,yc,0,130,l,loop1);
    l=124;
    if(dispMode){
    glColor3ub(38,38,38);
    }else{
    glColor3ub(245,245,255);
    }
    drawDesign(xc,yc,-1,131,l,loop1);



    l=128;
    if(dispMode){
    glColor3ub(218,112,214);
    }else{
    glColor3ub(127,255,0);
    }
    drawDesign(xc,yc,160,270,l,loop1);
    l=124;
    if(dispMode){
    glColor3ub(38,38,38);
    }else{
    glColor3ub(245,245,255);
    }
    drawDesign(xc,yc,159,271,l,loop1);





    l=121;
    if(dispMode){
    glColor3ub(153,50,204);
    }else{
    glColor3ub(0,250,154);
    }
    drawDesign(xc,yc,70,200,l,loop2);
    l=118;
    if(dispMode){
    glColor3ub(38,38,38);
    }else{
    glColor3ub(245,245,255);
    }
    drawDesign(xc,yc,69,201,l,loop2);



    l=121;
    if(dispMode){
    glColor3ub(153,50,204);
    }else{
    glColor3ub(0,250,154);
    }
    drawDesign(xc,yc,240,380,l,loop2);
    l=118;
    if(dispMode){
    glColor3ub(38,38,38);
    }else{
    glColor3ub(245,245,255);
    }
    drawDesign(xc,yc,239,381,l,loop2);

// デザイン回転
    loop1+=0.05;
    loop2-=0.1;
    if(loop1>=2*M_PI){
        loop1=0;
    }
    if(loop2<=-2*M_PI){
        loop2=0;
    }

// year,month,dayを表示
    month = ts->tm_mon; // 月の番号を取得
    wday =  ts->tm_wday; // 曜日の番号を取得 
    // 可変文字列生成
    timestr_len+=strlen(month_eg[month])+strlen(wday_eg[wday]); // 文字数計算
    timestr = (char *)malloc(timestr_len*sizeof(char)); // 配列確保
    sprintf(timestr,"%d %s %02d (%s)",1900+ts->tm_year,month_eg[month],ts->tm_mday,
    wday_eg[wday]); // timestrに文字列書き込み
    // 文字列表示
    if(dispMode){
    glColor3ub(0,191,255);
    }else{
    glColor3ub(255,102,0);
    }
    Printstr(xc-(18*timestr_len/4),30+1,timestr,timestr_len); // 文字列表示
    // 領域解放
    free(timestr);

//hour,min,secを表示
    // 文字列生成
    timestr = (char *)malloc(9*sizeof(char)); // 配列確保
    // timestrに文字列書き込み
    sprintf(timestr,"%02d:%02d:%02d",ts->tm_hour,ts->tm_min,ts->tm_sec);
    timestr_len = strlen(timestr); // 文字列の長さを取得
    // 文字列表示
    if(dispMode){
    glColor3ub(0,255,0);
    }else{
    glColor3ub(0,0,205);
    }
    Printstr(xc-(18*timestr_len/4)+1,60,timestr,timestr_len); // 文字列表示(太文字用)
    if(dispMode){
    glColor3ub(51,255,102);
    }else{
    glColor3ub(0,0,205);
    }
    Printstr(xc-(18*timestr_len/4),60,timestr,timestr_len); // 文字列表示
    // 領域解放
    free(timestr);

// インデックス描画
    for(i=1;i<=60;i++){
        if(dispMode){
        glColor3ub(255,255,255);
        }else{
        glColor3ub(0,0,0);
        }
        glLineWidth(2.0);
        l=100; // インデックスの先端を長さ110にする
        if(i%5==0){  // 5の倍数の針は長くする
        l = 90; // インデックスの終端を長さ90にする
        }
        theta = 2*M_PI*i/60;
        calPosition(&x1,&y1,xc,yc,l,theta);
        l = 110;
        calPosition(&x2,&y2,xc,yc,l,theta);
        drawLine(x1,y1,x2,y2);

        if(i%5==0){ // 5の倍数のとき文字を表示
            sprintf(s,"%d",i/5);
            l =80; // 文字表示位置を80にする
            calPosition(&x2,&y2,xc,yc,l,theta);
            if(i/5<10){ // 一桁表示用
                glRasterPos2i(x2-5,y2+5);
                glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,s[0]);

            }else{ // 二桁表示用
                glRasterPos2i(x2-14,y2+5);
                glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,s[0]);
                glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,s[1]);
            }
        }
    }

// 針を描画
    //時針描画
    if(dispMode){
    glColor3ub(255,255,255);
    }else{
    glColor3ub(0,0,0);
    }
    glLineWidth(5.0);
    drawLine(xc,yc,xh,yh);
    //分針描画
    glLineWidth(3.0);
    drawLine(xc,yc,xm,ym);
    //秒針描画
    glLineWidth(2.0);
    glColor3ub(255,0,0);
    drawLine(xc,yc,xs,ys);

    glFlush();
}


// windowサイズが変更されたときの処理
void Reshape(int w,int h){
    //printf("ウィンドウの幅と高さ=%d x %d\n",w,h);
    glViewport(0,0,w,h);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluOrtho2D(0,w,0,h);
    glScaled(1,-1,1);
    glTranslated(0,-h,0);

    //windowサイズ固定 
    glutReshapeWindow(WINDOW_W,WINDOW_H);

}

// タイマーの処理
void Timer(int value){
    glutPostRedisplay();
    glutTimerFunc(500,Timer,0);
}

// 文字列描画
//座標(x,y)を初期位置として文字列str(文字列の長さstrlen)を画面に描画
void Printstr(int x,int y,char *str,int strlen){
    int i;
    glRasterPos2i(x,y);
    for(i=0;i<strlen;i++){
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18,str[i]);
    }
}

// 極座標と直交座標を変換
//極座標(r,theta)を(xc,yc)を原点とした直交座標(x,y)に変換
void calPosition(int *x,int *y,int xc,int yc,int r,double theta){
    *x = xc+r*sin(theta);
    *y = yc-r*cos(theta);
}

// lineを描画
//(x1,y1)と(x2,y2)を結ぶ直線を描画
void drawLine(int x1,int y1,int x2,int y2){
    glBegin(GL_LINES);
    glVertex2i(x1,y1);
    glVertex2i(x2,y2);
    glEnd();
};

// デザインを描画
// (xc,yc)を原点とする極座標をとる.
// この極座標でthetaStartからtheraEndまで,長さlの扇形を描画する.
// loopは扇形を回転させる変数.
void drawDesign(int xc,int yc,int thetaStart,int thetaEnd,int l,double loop){
    int x,y,i;
    double theta;
    glBegin(GL_POLYGON);
    for(i=thetaStart;i<=thetaEnd;i++){
        theta= 2*M_PI*i/360;
        calPosition(&x,&y,xc,yc,l,theta+loop);
        glVertex2i(x,y);
    }
    glEnd();
}

// 左クリック時にmodeを切り替える
void Mouse(int b,int s,int x,int y){
    if(b==GLUT_LEFT_BUTTON){
        if(s==GLUT_UP){
            if(dispMode==1){
                dispMode=0;
            }else{
                dispMode=1;
            }
        }
        if(dispMode){
            glClearColor(0.15,0.15,0.15,1.0);
        }else{
            glClearColor(0.96,0.96,1.0,1.0);
        }
    }
}
        \end{lstlisting}
\end{document}